## lss流媒体项目
### 工程目录结构
```c++
lss/
    |-- bin/
    |-- build/ 存放编译产生的中间文件
    |-- src/
        |-- base/ 存放基础函数库，该目录下的源文件将被编译成一个`libbase.a`的库
            |-- CMakeLists.txt 
            |-- TTime.h
            |-- TTime.cpp 时间常用函数，测量事件的时长以及当前时间，通过一个返回当前系统的UTC时间进行计算
            |-- StringUtils.h
            |-- StringUtils.cpp 字符串操作函数，实现字符串前缀和后缀匹配，文件名、文件路径的操作，字符串的分割
            |-- NonCopyable.h 不可移动和复制的`基类`
            |-- Singleton.h 单例模式
            |-- TestSingleton.cpp 测试单例模式
            |-- Task.h 定时任务头文件
            |-- Task.cpp 定时任务方法的实现
        |-- main/
        |-- CMakeLists.txt 指定编译的源文件目录，生成程序名，编译完成后执行安装
    |-- CMakeLists.txt  设置全局编译参数，程序输出目录，编译的子目录
    |-- README.md
```
### 通用基础函数库的实现
<br>
---------------------------------------------------------------------------------------------------------------------------------
实现单例模式，保证一个类仅有一个实例（只能自行创建实例；多线程初始化竞争，保证只创建一个实例；不可复制和移动），并提供一个访问实例的全局访问点。
<br>
C++的`三/五法则`：拷贝构造函数、拷贝赋值运算符、析构函数、移动构造函数、移动赋值运算符。实现了上述5个法则中的任意一个，编译器会默认合成另外的4个法则，反之删除其中任意一个法则，编译器则不会默认合成另外的4个法则。
<br>
---------------------------------------------------------------------------------------------------------------------------------
定时任务：在规定的时间执行；可以单次执行，也可以重复执行；通过回调函数执行任务。
<br>
定时任务的运行（由谁检测任务时间？由谁执行定时任务？）--> 定时任务管理器：存放所有的定时任务；添加定时任务；删除定时任务；检测每个任务是否到点执行；执行任务；定时任务为全局唯一
<br>
定时任务管理器的算法：<br>
- **直接遍历（容器：unordered_set；插入：O(1)；遍历：O(n)）；**<br>
    - 实现简单；<br>
    - 任务事件重新更新后不需要调整任务列表；<br>
    - 全局定时任务数量少，局限于后续网络库中与事件循环绑定的局部定时任务；<br>
- 最小时间堆：遍历任务，总是取堆顶任务进行判断，如果堆顶任务未到时间，退出遍历，否则继续执行任务，并设置下一个时间点，随后重建堆，保证堆顶时间为最小的时间（容器：vector、std::make_heap、std::push_heap、std::pop_heap；插入：O(logn)；遍历：不稳定任务未到时间，直接退出，O(1)，如果所有任务到了时间，需要继续执行任务，并设置下一个时间点，随后重建堆，O(nlogn)）；<br>
- 时间轮：以固定的时间间隔执行当前指向的任务，最右边的时间轮转动一圈后，左边的时间轮转动一格，以此类推（容器：vector、queue、unordered_set；插入：O(1)；遍历：O(1)）。
<br>
---------------------------------------------------------------------------------------------------------------------------------